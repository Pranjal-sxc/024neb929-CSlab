<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 2: C Programming Fundamentals - Grade 12</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            color: #333;
            line-height: 1.6;
        }
        header {
            background-color: #0077b6;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        nav {
            background-color: #023e8a;
            padding: 10px;
            text-align: center;
        }
        nav a {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            display: inline-block;
            transition: background-color 0.3s;
            border-radius: 4px;
            margin: 0 5px;
            font-weight: 600;
        }
        nav a:hover {
            background-color: #0096c7;
        }
        .content {
            padding: 20px;
            max-width: 900px;
            margin: 20px auto;
            background: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        h2 {
            color: #0077b6;
            margin-top: 30px;
            margin-bottom: 10px;
        }
        h3 {
            color: #023e8a;
            margin-top: 20px;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        ul li {
            background: #e3f2fd;
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
        }
        p {
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #0077b6;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            margin: 10px 0 20px;
        }
        footer {
            text-align: center;
            padding: 10px;
            background-color: #023e8a;
            color: white;
            margin-top: 30px;
            font-size: 14px;
        }
        /* Smaller indent for nested lists */
        ul ul {
            list-style-type: circle;
        }
        
        /* Professional image styling */
        img.professional-image {
            max-width: 43.69%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            object-fit: contain;
        }
        
        /* Code Block Styling */
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .active-link {
            background-color: #0096c7;
        }

    </style>
</head>
<body>

<header>
    Chapter 2: C Programming Fundamentals - Grade 12
</header>

<nav>
    <a href="chapter1.html">DBMS</a>
    <a href="chapter2.html" class="active-link">C Programming</a>
    <a href="#">Chapter 3</a>
    <a href="#">Chapter 4</a>
    <a href="#">Chapter 5</a>
    <a href="#">Chapter 6</a>
</nav>

<div class="content">

    <h2>1. Functions in C</h2>
    <p>A function is a block of code that performs a specific task. By dividing a complex program into smaller, manageable functions, it becomes easier to understand, debug, and maintain. Functions are a core part of modular programming in C.</p>

    <h3>Introduction and Syntax</h3>
    <p>A function in C consists of a declaration (prototype), a definition, and a call. It takes input (arguments), processes it, and returns an output.</p>
    <pre><code>
// Function Prototype (Declaration)
returnType functionName(dataType parameter1, dataType parameter2, ...);

// Function Definition
returnType functionName(dataType parameter1, dataType parameter2, ...) {
    // block of code to be executed
    ...
    return value; // Optional
}

// Function Call
result = functionName(argument1, argument2, ...);
    </code></pre>

    <h3>Purpose and Advantages of Functions</h3>
    <ul>
        <li><strong>Reusability:</strong> A function can be called multiple times from different parts of the program, reducing code duplication.</li>
        <li><strong>Modularity:</strong> Breaks down a large program into smaller, independent modules, making the code easier to manage.</li>
        <li><strong>Readability:</strong> Improves the clarity and organization of the code.</li>
        <li><strong>Debugging:</strong> It is easier to identify and fix errors in smaller, isolated functions.</li>
    </ul>

    <h3>Components of a Function</h3>
    <ul>
        <li><strong>Function Prototype (Declaration):</strong> Informs the compiler about a function's name, return type, and parameters. It must be declared before the function is called.</li>
        <li><strong>Function Definition:</strong> Contains the actual block of code for the function's task.</li>
        <li><strong>Function Call:</strong> The statement that executes the function's code.</li>
        <li><strong>Return Statement:</strong> Used to send a value back from the function to the calling part of the program.</li>
    </ul>

    <h3>Types of Functions</h3>
    <p>Functions can be broadly categorized into two types:</p>
    <ul>
        <li><strong>Library Functions:</strong> Pre-defined functions available in C's standard library (e.g., <code>printf()</code>, <code>scanf()</code>, <code>sqrt()</code>). You just need to include the appropriate header file.</li>
        <li><strong>User-Defined Functions:</strong> Functions created by the programmer to perform specific tasks.</li>
    </ul>

    <h3>Passing Arguments</h3>
    <p>Arguments can be passed to functions in two main ways:</p>
    <ul>
        <li><strong>Call By Value:</strong> A copy of the argument's value is passed to the function. Any changes made to the parameter inside the function do not affect the original variable. </li>
        <li><strong>Call By Reference:</strong> The address of the argument is passed. The function can then directly access and modify the original variable using this address. </li>
    </ul>

    <h3>Variable and its Scope</h3>
    <p>The scope of a variable determines where it can be accessed within a program.</p>
    <ul>
        <li><strong>Local Variables:</strong> Declared inside a function or a block. They can only be accessed within that function or block.</li>
        <li><strong>Global Variables:</strong> Declared outside all functions. They can be accessed from any function in the program.</li>
    </ul>

    <h3>Storage Classes</h3>
    <p>Storage classes determine the scope, lifetime, and storage location of variables.</p>
    <ul>
        <li><strong>Automatic (<code>auto</code>):</strong> Default storage class for local variables. Stored on the stack. Life is limited to the function block.</li>
        <li><strong>External (<code>extern</code>):</strong> Used to declare a global variable that is defined in another file. It extends the variable's visibility.</li>
        <li><strong>Static (<code>static</code>):</strong> For local variables, it retains the value between function calls. For global variables, it limits visibility to the current file.</li>
        <li><strong>Register (<code>register</code>):</strong> Suggests to the compiler to store the variable in a CPU register for faster access.</li>
    </ul>

    <h3>Function with Array Example</h3>
    <p>To pass an array to a function, you pass the array's name, which decays into a pointer to its first element. The function can then access and modify the array's elements.</p>
    <pre><code>
#include &lt;stdio.h&gt;

void printArray(int arr[], int size) {
    printf("Elements of array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int myArray[] = {10, 20, 30, 40, 50};
    int n = sizeof(myArray) / sizeof(myArray[0]);
    printArray(myArray, n);
    return 0;
}
    </code></pre>

    <h3>Recursive Function</h3>
    <p>A recursive function is a function that calls itself. It is used to solve problems that can be broken down into smaller, self-similar sub-problems.</p>
    <h4>Syntax:</h4>
    <pre><code>
void recursiveFunction() {
    if (condition) {
        // base case to stop recursion
        return;
    }
    recursiveFunction(); // recursive call
}
    </code></pre>
    <h4>Example: Factorial Calculation</h4>
    <pre><code>
#include &lt;stdio.h&gt;

long long factorial(int n) {
    // Base case: to stop the recursion
    if (n >= 1) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

int main() {
    int number = 5;
    printf("Factorial of %d = %lld\n", number, factorial(number));
    return 0;
}
    </code></pre>
    <h4>Advantages and Disadvantages of Recursion:</h4>
    <ul>
        <li><strong>Advantages:</strong>
            <ul>
                <li>Code is often more elegant and shorter.</li>
                <li>Reduces code size and improves readability.</li>
                <li>Suitable for problems with a recursive nature (e.g., tree traversals, quicksort).</li>
            </ul>
        </li>
        <li><strong>Disadvantages:</strong>
            <ul>
                <li>Can be slower due to function call overhead.</li>
                <li>Uses more memory (stack space).</li>
                <li>Difficult to debug.</li>
            </ul>
        </li>
    </ul>

    <h2>2. Structure and Union</h2>
    <p>Structures and Unions are user-defined data types in C that allow you to combine different data types under a single name.</p>
    <h3>Structure (<code>struct</code>)</h3>
    <p>A structure is a collection of variables of different data types under a single name. Each member in a structure has its own memory location.</p>
    <h4>Introduction and Syntax:</h4>
    <pre><code>
// Defining a structure
struct Student {
    char name[50];
    int rollNumber;
    float marks;
};
    </code></pre>
    <h4>Structure Size and Accessing Members:</h4>
    <p>The size of a structure is the sum of the sizes of all its members, plus any padding added by the compiler. You can access members using the dot (<code>.</code>) operator.</p>
    <pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Student {
    char name[50];
    int rollNumber;
    float marks;
};

int main() {
    struct Student s1;
    strcpy(s1.name, "Alice");
    s1.rollNumber = 101;
    s1.marks = 85.5;

    printf("Student Name: %s\n", s1.name);
    printf("Roll Number: %d\n", s1.rollNumber);
    printf("Marks: %.2f\n", s1.marks);

    printf("Size of Student structure: %lu bytes\n", sizeof(struct Student));
    return 0;
}
    </code></pre>

    <h3>Nested Structure</h3>
    <p>A nested structure is a structure that contains another structure as one of its members.</p>
    <pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct DateOfBirth {
    int day;
    int month;
    int year;
};

struct Student {
    char name[50];
    int rollNumber;
    struct DateOfBirth dob; // Nested structure
};

int main() {
    struct Student s1;
    strcpy(s1.name, "Bob");
    s1.rollNumber = 102;
    s1.dob.day = 15;
    s1.dob.month = 6;
    s1.dob.year = 2005;

    printf("Student Name: %s\n", s1.name);
    printf("Date of Birth: %d-%d-%d\n", s1.dob.day, s1.dob.month, s1.dob.year);
    return 0;
}
    </code></pre>

    <h3>Array of Structure</h3>
    <p>An array of structures allows you to store multiple records of the same structure type.</p>
    <pre><code>
#include &lt;stdio.h&gt;

struct Student {
    char name[50];
    int rollNumber;
};

int main() {
    struct Student class[3]; // Array of 3 Student structures

    class[0].rollNumber = 101;
    strcpy(class[0].name, "Alice");
    class[1].rollNumber = 102;
    strcpy(class[1].name, "Bob");
    class[2].rollNumber = 103;
    strcpy(class[2].name, "Charlie");

    for (int i = 0; i < 3; i++) {
        printf("Student %d: %s (Roll No: %d)\n", i+1, class[i].name, class[i].rollNumber);
    }
    return 0;
}
    </code></pre>

    <h3>Passing Structure to Function</h3>
    <p>You can pass an entire structure to a function, either by value or by reference (using pointers).</p>
    <pre><code>
#include &lt;stdio.h&gt;

struct Point {
    int x;
    int y;
};

// Pass by value
void printPoint(struct Point p) {
    printf("Point coordinates (pass by value): (%d, %d)\n", p.x, p.y);
}

// Pass by reference
void modifyPoint(struct Point *p) {
    p->x = 20;
    p->y = 40;
}

int main() {
    struct Point p1 = {10, 20};
    printPoint(p1);
    modifyPoint(&p1);
    printf("Modified point coordinates (pass by reference): (%d, %d)\n", p1.x, p1.y);
    return 0;
}
    </code></pre>

    <h3>Union (<code>union</code>)</h3>
    <p>A union is a special data type that allows different members to share the **same memory location**. The size of a union is determined by its largest member.</p>
    <h4>Introduction and Syntax:</h4>
    <pre><code>
// Defining a union
union Data {
    int i;
    float f;
    char str[20];
};
    </code></pre>

    <h3>Comparison between Structure and Union</h3>
    <table border="1">
        <tr>
            <th>Feature</th>
            <th>Structure</th>
            <th>Union</th>
        </tr>
        <tr>
            <td><strong>Memory Allocation</strong></td>
            <td>Each member has its own unique memory location.</td>
            <td>All members share the same memory location.</td>
        </tr>
        <tr>
            <td><strong>Size</strong></td>
            <td>Sum of the sizes of all its members (plus padding).</td>
            <td>Equal to the size of the largest member.</td>
        </tr>
        <tr>
            <td><strong>Value Storage</strong></td>
            <td>All members can store values simultaneously.</td>
            <td>Only one member can store a value at a time. The last assigned value overwrites previous ones.</td>
        </tr>
        <tr>
            <td><strong>Keyword</strong></td>
            <td><code>struct</code></td>
            <td><code>union</code></td>
        </tr>
    </table>

    <h2>3. Pointers</h2>
    <p>A pointer is a variable that stores the memory address of another variable. It is a fundamental and powerful concept in C.</p>
    <h3>Introduction and Syntax:</h3>
    <p>Pointers are declared using an asterisk (<code>*</code>).</p>
    <pre><code>
dataType *pointerName;
    </code></pre>
    <p>The address of a variable is obtained using the address-of operator (<code>&</code>), and the value at an address is accessed using the dereference operator (<code>*</code>).</p>

    <h3>Concept of Value and Address</h3>
    <p>Every variable has a value and a memory address. The value is the data stored in that memory location, and the address is the location itself.  A pointer holds an address as its value.</p>
    <h4>Declaration and Initialization:</h4>
    <pre><code>
#include &lt;stdio.h&gt;

int main() {
    int var = 10;
    int *ptr; // Pointer declaration
    ptr = &var; // Pointer initialization (stores address of var)

    printf("Value of var: %d\n", var);
    printf("Address of var: %p\n", &var);
    printf("Value stored in ptr (address): %p\n", ptr);
    printf("Value pointed to by ptr: %d\n", *ptr);
    return 0;
}
    </code></pre>

    <h3>Pointer and Function: Call by Reference</h3>
    <p>Pointers are essential for implementing "call by reference," allowing a function to modify the actual variables in the calling function. The address is passed to the function, and the pointer inside the function can dereference it to modify the original value.</p>
    <pre><code>
#include &lt;stdio.h&gt;

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    printf("Before swap: x = %d, y = %d\n", x, y);
    swap(&x, &y); // Pass addresses
    printf("After swap: x = %d, y = %d\n", x, y);
    return 0;
}
    </code></pre>
    <h4>Comparison between Call by Value and Call by Reference:</h4>
    <table border="1">
        <tr>
            <th>Aspect</th>
            <th>Call by Value</th>
            <th>Call by Reference</th>
        </tr>
        <tr>
            <td><strong>What is Passed</strong></td>
            <td>A copy of the argument's value.</td>
            <td>The memory address of the argument.</td>
        </tr>
        <tr>
            <td><strong>Modification</strong></td>
            <td>Changes inside the function do not affect the original variable.</td>
            <td>Changes inside the function do affect the original variable.</td>
        </tr>
        <tr>
            <td><strong>Memory</strong></td>
            <td>Separate memory is allocated for the parameter.</td>
            <td>The same memory location is used for the variable.</td>
        </tr>
        <tr>
            <td><strong>Use Case</strong></td>
            <td>When you want to protect the original data from modification.</td>
            <td>When you need to modify the original data.</td>
        </tr>
    </table>

    <h3>Pointer with Arrays</h3>
    <p>An array's name acts as a constant pointer to its first element. This means you can use pointers to access and traverse array elements.</p>
    <pre><code>
#include &lt;stdio.h&gt;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr; // ptr points to the first element (arr[0])

    // Accessing elements using pointer arithmetic
    printf("Value of arr[0]: %d\n", *ptr);
    printf("Value of arr[1]: %d\n", *(ptr + 1));
    printf("Value of arr[2]: %d\n", *(ptr + 2));
    
    // Traversing the array
    printf("\nTraversing array with pointer:\n");
    for(int i = 0; i < 5; i++) {
        printf("%d ", *(ptr + i));
    }
    printf("\n");
    return 0;
}
    </code></pre>
    <h4>Advantages and Disadvantages of Pointers:</h4>
    <ul>
        <li><strong>Advantages:</strong>
            <ul>
                <li>Efficient memory management and dynamic memory allocation.</li>
                <li>Reduces code size and improves performance for large data sets.</li>
                <li>Allows for passing variables by reference to functions.</li>
            </ul>
        </li>
        <li><strong>Disadvantages:</strong>
            <ul>
                <li>Can lead to memory leaks and dangling pointers if not managed correctly.</li>
                <li>Complex to understand for beginners.</li>
                <li>Unsafe if not handled carefully.</li>
            </ul>
        </li>
    </ul>

    <h2>4. File Handling</h2>
    <p>File handling in C allows a program to store and retrieve data from files on disk, ensuring data persistence even after the program terminates.</p>
    <h3>Concept of Data File and Need for File Handling in C</h3>
    <p>A data file is a collection of related records stored on a physical storage device. File handling is necessary for managing data that needs to be stored permanently and shared between different program executions.</p>
    <p>Files can be categorized as **Sequential** (accessed in a sequence from beginning to end) or **Random** (accessed directly at any location). Most of the file handling functions are for sequential access.</p>

    <h3>File Handling Functions</h3>
    <p>These are standard library functions for performing file operations. All of them use a file pointer (<code>FILE*</code>).</p>
    <ul>
        <li><code><strong>FILE *fopen(const char *filename, const char *mode);</strong></code>: Opens a file and returns a file pointer. Returns <code>NULL</code> on failure.
            <ul><li><code>filename</code>: The name of the file to open.</li><li><code>mode</code>: The file opening mode (e.g., "r", "w", "a").</li></ul>
        </li>
        <li><code><strong>int fclose(FILE *fp);</strong></code>: Closes an opened file and flushes its buffer.
            <ul><li><code>fp</code>: The file pointer of the file to close.</li></ul>
        </li>
        <li><code><strong>int getc(FILE *fp);</strong></code>: Reads a single character from the file.</li>
        <li><code><strong>int putc(int c, FILE *fp);</strong></code>: Writes a single character to the file.</li>
        <li><code><strong>int fprintf(FILE *fp, const char *format, ...);</strong></code>: Writes formatted data to a file.</li>
        <li><code><strong>int fscanf(FILE *fp, const char *format, ...);</strong></code>: Reads formatted data from a file.</li>
        <li><code><strong>int getw(FILE *fp);</strong></code>: Reads an integer from a file.</li>
        <li><code><strong>int putw(int w, FILE *fp);</strong></code>: Writes an integer to a file.</li>
        <li><code><strong>char *fgets(char *str, int n, FILE *fp);</strong></code>: Reads a line of text from a file into a string.
            <ul><li><code>str</code>: The buffer to store the string.</li><li><code>n</code>: The maximum number of characters to read.</li></ul>
        </li>
        <li><code><strong>int fputs(const char *str, FILE *fp);</strong></code>: Writes a string to a file.</li>
        <li><code><strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);</strong></code>: Reads a block of data from a file.</li>
        <li><code><strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp);</strong></code>: Writes a block of data to a file.</li>
        <li><code><strong>int remove(const char *filename);</strong></code>: Deletes a file.</li>
        <li><code><strong>int rename(const char *old_filename, const char *new_filename);</strong></code>: Renames a file.</li>
    </ul>

    <h3>Random Access Functions</h3>
    <p>These functions allow you to move the file pointer to any location in the file for random access.</p>
    <ul>
        <li><code><strong>int fseek(FILE *fp, long int offset, int origin);</strong></code>: Sets the file pointer to a specific position.
            <ul><li><code>offset</code>: Number of bytes to move.</li><li><code>origin</code>: Starting position (<code>SEEK_SET</code> for beginning, <code>SEEK_CUR</code> for current, <code>SEEK_END</code> for end).</li></ul>
        </li>
        <li><code><strong>void rewind(FILE *fp);</strong></code>: Resets the file pointer to the beginning of the file.</li>
        <li><code><strong>long int ftell(FILE *fp);</strong></code>: Returns the current position of the file pointer.</li>
    </ul>

    <h3>File Opening Modes</h3>
    <ul>
        <li><strong>Read (<code>r</code>, <code>r+</code>):</strong> Opens a file for reading. The file must exist. <code>r+</code> also allows writing.</li>
        <li><strong>Write (<code>w</code>, <code>w+</code>):</strong> Opens a file for writing. If the file exists, its content is erased. If not, a new file is created. <code>w+</code> also allows reading.</li>
        <li><strong>Append (<code>a</code>, <code>a+</code>):</strong> Opens a file for writing, but at the end of the file. If the file does not exist, a new one is created. <code>a+</code> also allows reading.</li>
    </ul>

    <h3>Steps to Work with File in C</h3>
    <ol>
        <li><strong>Define File Pointer:</strong> Create a pointer of type <code>FILE</code>. Example: <code>FILE *fp;</code></li>
        <li><strong>Open File with Required Mode:</strong> Use <code>fopen()</code> to open the file.</li>
        <li><strong>Read, Write, Append Operations:</strong> Perform the desired operation using appropriate functions.</li>
        <li><strong>Close the File:</strong> Use <code>fclose()</code> to close the file and save changes.</li>
    </ol>

    <h4>Reading Data from Files:</h4>
    <pre><code>
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    char buffer[100];
    fp = fopen("example.txt", "r");
    if (fp == NULL) {
        printf("Error opening file!\n");
        return 1;
    }
    while (fgets(buffer, 100, fp) != NULL) {
        printf("%s", buffer);
    }
    fclose(fp);
    return 0;
}
    </code></pre>

    <h4>Writing Data on Files:</h4>
    <pre><code>
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    fp = fopen("example_write.txt", "w");
    if (fp == NULL) {
        printf("Error creating file!\n");
        return 1;
    }
    fprintf(fp, "Hello, world!\n");
    fprintf(fp, "This is a test.");
    fclose(fp);
    printf("Data written to file successfully.\n");
    return 0;
}
    </code></pre>

    <h4>Appending Data Files:</h4>
    <pre><code>
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    fp = fopen("example_write.txt", "a");
    if (fp == NULL) {
        printf("Error opening file!\n");
        return 1;
    }
    fprintf(fp, "\nAppending a new line.");
    fclose(fp);
    printf("Data appended to file successfully.\n");
    return 0;
}
    </code></pre>

    <h3>End of File (EOF)</h3>
    <p><code>EOF</code> is a macro defined in <code>stdio.h</code> that stands for "End of File." It's a special constant value returned by file input functions (like <code>getc()</code> or <code>fscanf()</code>) to indicate that the end of the file has been reached, preventing the program from reading beyond the file's content.</p>

    <h2>5. The <code>typedef</code> Keyword</h2>
    <p>The <code>typedef</code> keyword is used to create an alias or a new name for an existing data type. It is commonly used to make code more readable and portable.</p>
    <h4>Syntax:</h4>
    <pre><code>
typedef existing_dataType new_name;
    </code></pre>
    <h4>Example:</h4>
    <pre><code>
#include &lt;stdio.h&gt;

typedef unsigned int UINT;
typedef struct Student Student;

struct Student {
    char name[50];
    int rollNumber;
};

int main() {
    UINT number = 100;
    Student s1; // Using the new alias
    s1.rollNumber = 20;

    printf("Number: %u\n", number);
    printf("Student roll number: %d\n", s1.rollNumber);
    return 0;
}
    </code></pre>

</div>

<footer>
    © 2024 Grade 12 Computer Science
</footer>

</body>
</html>
